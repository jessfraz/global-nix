#!/usr/bin/env bash
set -o pipefail

remote=origin
force=0
base=""
nogc=0

while [ $# -gt 0 ]; do
    case "$1" in
        -f|--force)
            force=1
            shift
            ;;
        -r|--remote)
            shift
            [ -n "$1" ] && remote="$1"
            shift
            ;;
        -b|--base)
            shift
            [ -n "$1" ] && base="$1"
            shift
            ;;
        --no-gc)
            nogc=1
            shift
            ;;
        *)
            echo "Unknown option: $1"
            exit 2
            ;;
    esac
done

if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "Not a git repo"
    exit 1
fi

unset GIT_DIR
unset GIT_WORK_TREE
unset GIT_COMMON_DIR

cur_wt=$(git rev-parse --show-toplevel)
common_abs=$(git rev-parse --path-format=absolute --git-common-dir 2>/dev/null || true)
main_wt=""
if [ -n "$common_abs" ]; then
    main_wt=$(cd "$common_abs/.." && pwd -P)
else
    while read -r key value; do
        if [ "$key" = "worktree" ]; then
            main_wt="$value"
            break
        fi
    done < <(git worktree list --porcelain)
fi

if [ -z "$main_wt" ] || [ ! -d "$main_wt/.git" ]; then
    echo "Cannot determine main worktree."
    exit 1
fi

if [ -z "$base" ]; then
    tmp=$(git symbolic-ref --short "refs/remotes/$remote/HEAD" 2>/dev/null)
    if [ -n "$tmp" ]; then
        base=$(printf "%s" "$tmp" | sed "s@^$remote/@@")
    fi
fi
if [ -z "$base" ]; then
    if git show-ref --verify --quiet refs/heads/main; then
        base=main
    elif git show-ref --verify --quiet refs/heads/master; then
        base=master
    else
        echo "Cannot determine default branch. Use -b <name>."
        exit 1
    fi
fi

if ! git diff --quiet || ! git diff --cached --quiet; then
    echo "Working tree not clean; commit/stash first."
    exit 1
fi

cur=$(git symbolic-ref --quiet --short HEAD || echo HEAD)

gitc() {
    git -C "$main_wt" "$@"
}

warn() {
    printf '%s\n' "$*" >&2
}

submodule_paths() {
    git -C "$1" config -f .gitmodules --get-regexp '^submodule\..*\.path$' 2>/dev/null \
        | awk '{print $2}'
}

cleanup_worktree_submodules() {
    local wt="$1"

    [ -f "$wt/.gitmodules" ] || return 0

    git -C "$wt" submodule deinit -f --all || true
    while read -r path; do
        [ -n "$path" ] || continue
        rm -rf "$wt/$path" || true
    done < <(submodule_paths "$wt")
}

remove_worktree() {
    local wt="$1"
    local args=()

    if [ "$force" -eq 1 ]; then
        args+=(--force)
    fi

    cleanup_worktree_submodules "$wt"

    if gitc worktree remove "${args[@]}" "$wt"; then
        return 0
    fi

    warn "git worktree remove failed for $wt, removing directory and pruning metadata."
    rm -rf "$wt" || true
    gitc worktree prune || true
    return 0
}

del_branch() {
    if [ "$force" -eq 1 ]; then
        gitc branch -D "$cur" || true
        return 0
    fi

    upstream=$(gitc for-each-ref --format='%(upstream:short)' "refs/heads/$cur")
    if [ -n "$upstream" ] && [ "$upstream" = "$remote/$cur" ]; then
        if ! gitc show-ref --verify --quiet "refs/remotes/$remote/$cur"; then
            echo "Remote branch $remote/$cur gone; deleting local branch."
            gitc branch -D "$cur" || true
            return 0
        fi
    fi

    if gitc merge-base --is-ancestor "$cur" "$base" 2>/dev/null; then
        gitc branch -d "$cur" || true
        return 0
    fi

    if gitc show-ref --verify --quiet "refs/remotes/$remote/$base" \
        && gitc merge-base --is-ancestor "$cur" "$remote/$base" 2>/dev/null; then
        gitc branch -D "$cur" || true
        return 0
    fi

    echo "Branch '$cur' not merged. Re-run with -f to force."
}

if [ "$cur_wt" != "$main_wt" ]; then
    remove_worktree "$cur_wt"

    gitc fetch "$remote" --prune --tags

    if ! gitc diff --quiet || ! gitc diff --cached --quiet; then
        echo "Main worktree not clean; skipping base update."
    else
        main_cur=$(gitc symbolic-ref --quiet --short HEAD || echo HEAD)
        if [ "$main_cur" != "$base" ]; then
            gitc switch "$base"
        fi
        gitc pull --ff-only "$remote" "$base"
    fi

    if [ "$cur" != "HEAD" ] && [ "$cur" != "$base" ]; then
        del_branch
    else
        echo "Already on $base or detached HEAD; skipping delete."
    fi

    gitc remote prune "$remote" || true
    gitc worktree prune || true
    if [ "$nogc" -ne 1 ]; then
        gitc gc --prune=now
    fi
    echo "Cleanup complete: base=$base remote=$remote"
    echo "Worktree removed: $cur_wt"
    echo "Run: cd $main_wt"
    exit 0
fi

gitc fetch "$remote" --prune --tags
if [ "$cur" != "HEAD" ] && [ "$cur" != "$base" ]; then
    gitc switch "$base"
    gitc pull --ff-only "$remote" "$base"
    del_branch
else
    gitc pull --ff-only "$remote" "$base"
    echo "Already on $base or detached HEAD; skipping delete."
fi
gitc remote prune "$remote" || true
gitc worktree prune || true
if [ "$nogc" -ne 1 ]; then
    gitc gc --prune=now
fi
echo "Cleanup complete: base=$base remote=$remote"
